#대분류/중분류 입력받는 함수
def business_filter():
    
    # 1. 대분류명 목록 출력
    print('📝 업종 리스트','>>',np.unique(business['대분류명']))
    print()

    # 2. 대분류 입력 받기
    category = input('🧡 어떤 분야의 창업을 원하시나요? 리스트에서 그대로 입력해주세요:')

    # 3. 중분류명 목록 출력
    category_list = np.unique(business[business['대분류명'] == category]['중분류명'])

    # 2-1. 입력한 대분류에 중분류 데이터가 없으면 대분류를 잘못 입력했다고 판단
    while not np.any(category_list):
        print('해당하는 업종 대분류가 없습니다.\n')
        category = input('조회할 업종의 대분류명을 다시 입력해주세요: \n')
        category_list = np.unique(business[business['대분류명'] == category]['중분류명'])

    print()
    print('\n📝 세부 업종 리스트', '>>',category_list)
    print()


    # 4. 중분류 입력 받기
    final_category = input('🧡 창업하고 싶은 {}의 세부 업종을 그대로 입력해주세요:'.format(category))

    # 4-1. 입력한 중분류가 해당 대분류명이 가지고 있는 리스트에 없으면 잘못 입력했다고 판단
    while final_category not in category_list:
        final_category = input('다시 입력해주세요: ')

    # 4-2. 중분류 코드 저장
    category_code=np.unique(business[business['중분류명']==final_category]['중분류코드'])[0]

    # 5. 입력한 값(중분류명)을 final_category로 받아두고, 다음 블루오션 필터링에서 검색어로 활용한다.
    

    # 6. 프로그램 결과 출력
    print('\n...\n...','\n 서울시내 {} 블루오션 찾기를 시작합니다.'.format(final_category))

    return final_category, category, category_code



  # 블루오션 필터링 함수 bluefilter정의

def bluefilter(category, df_bus, df_dongpeo, final_category_kor): #전처리한 데이터와, 입력받은 업종(category)를 받아 사용합니다

  # 필요한 데이터 정의
  #1. filtered_data : 특정 업종을 가진 상권 데이터를 분리해낸 데이터
  # 입력한 업종코드에 해당하는 상권을 filtered_data에 넣어준다. 예를 들어 한식(코드 I201)을 입력했을 경우, 한식업종 가게만 담은 데이터가 됨
  filtered_data = df_bus[df_bus['상권업종중분류코드'] == category].copy() 
 
 # dong_codes는 특정 업종 상권을 가진 행정동의 코드를 리스트로 넣은 것.
  dong_codes = list(set(filtered_data['행정동코드'])) 
 
  #2. df_filtered_dongpeo : 생활인구 데이터에서 특정 업종 상권을 가진 행정동에 해당하는 생활인구 데이터만을 뽑기 위한 데이터프레임
  df_filtered_dongpeo=pd.DataFrame() 
  for i in range(len(dong_codes)):     # df_filtered_dongpeo 데이터프레임을 만드는 과정-행정동코드가 dong_codes에 존재할 경우, df_dongpeo의 값을 넣어준다. 
    for j in range(len(df_dongpeo)):
      if df_dongpeo['행정동코드'][j] == dong_codes[i]:
            df_filtered_dongpeo = df_filtered_dongpeo.append(df_dongpeo.iloc[j])
  df_filtered_dongpeo.reset_index(drop=True, inplace=True)
  df_filtered_dongpeo = df_filtered_dongpeo.reindex(range(len(df_filtered_dongpeo)))

  #최종 나오는 데이터는 df_blue데이터. 여기에 행정동 코드, 이름, 동종업계, 생활인구 모두 넣어 블루오션 필터링에 사용
  df_blue=pd.DataFrame() 

  #df_blue의 컬럼들을 만들어주고, 행정동코드명은 미리 넣어준다
  df_blue['행정동코드명']=dong_codes 
  df_blue['총생활인구'] = 0
  df_blue['동종업계 수']= 0
  df_blue['행정동명']=np.nan

  #df_blue에 총생활인구, 동종업계 수를 넣어주는 과정
  for i in range(len(df_blue)):  
    for j in range(len(df_filtered_dongpeo)):
      if df_filtered_dongpeo['행정동코드'][j] == df_blue['행정동코드명'][i]:
              df_blue['총생활인구'][i] = df_filtered_dongpeo['총생활인구수'][j]
  for i in range(len(df_blue)):
    df_blue['동종업계 수'][i]=len(filtered_data[filtered_data['행정동코드'] == df_blue['행정동코드명'][i]])

  #df_blue에 행정동 코드가 있고 행정동명이없으므로 넣어줌
  for i in range(len(df_filtered_dongpeo)): 
    for j in range(len(df_blue)):
      if df_blue['행정동코드명'][j]==df_filtered_dongpeo['행정동코드'][i]:
        df_blue['행정동명'][j]=df_filtered_dongpeo['읍면동명'][i]

  #지수컬럼 만드는 코드. 지수 = 총생활인구/동종업계 수, 지수가 클수록 더 블루오션
  df_blue['지수']=df_blue['총생활인구']/df_blue['동종업계 수']  
  df_sorted_blue = df_blue.sort_values(by='지수', ascending=False)
  print('\n\n***❤️'+ str(final_category_kor) + ' 업종의 동종업계 대비 인구가 많은 행정동 상위 30개는 다음과 같습니다❤️***')
  print(list(df_sorted_blue['행정동명'].head(30)))
  print('\n\n\n')

  return df_sorted_blue.head(30)


#가중치 적용 함수
def score_weight():
  print('🧡 아래 항목들의 번호를 중요하다고 생각되는 순서대로 쉼표(,)로 구분하여 나열해주세요.\n')
  print('1. 잠재소비자 수       2. 폐업률       3. 임대료       4.매출\n')
  print('예시: 4,2,3,1')
  weight=input('입력: ')            # 순위 입력받아 weight에 저장
  print()

  weight_list=[]

  if ',' not in weight:               # 쉼표로 구분 안했을 경우 다시 입력받음
    print('쉼표를 포함하여 입력해주세요.\n')
    return score_weight()
    
  else:
    weight_str=weight.split(',')      # 쉼표 기준 split해서 weight_str에 저장
    for i in range(len(weight_str)):
      if weight_str[i].isdigit():     # weight_str에 저장된 문자열들이 전부 숫자라면
        weight_list=np.array(weight_str, dtype=int)      # 정수형으로 변환하여 weight_list에 저장
      else:
        print('숫자를 입력해주세요. \n')    # weight_str이 숫자가 아니라면 다시 입력받음
        return score_weight()
      
      if weight_list[i]<1 or weight_list[i]>4:        # weight_list의 요소가 1부터 4까지의 숫자가 아니라면 다시 입력받음
        print('1부터 4까지의 숫자를 입력해주세요.\n')
        return score_weight()
        
  return weight_list
  

 # 점수화 함수                                   
def score(filter,upjong,weight):      # 매개변수는 블루오션 필터링 거친 데이터/ 업종명(대분류) / 가중치입니다
  dongs=filter['행정동명']    # 위 블루오션에서 필터링된 행정동들 dongs에 저장

  db_df=pd.DataFrame(index=dongs, columns=['잠재소비자','폐업률','임대료', '매출'])   # 각 데이터 저장할 데이터프레임 생성
  
  # 업종이 소매업이면 잠재소비자의 생활용품 컬럼 저장
  if upjong == '소매업':               
    db_df['잠재소비자']=df_customer['생활용품']
    db_df['잠재소비자']=db_df['잠재소비자'].fillna(db_df['잠재소비자'].mean())    # 결측치는 각 컬럼의 평균값으로 채웁니다

  # 숙박업이나 여가관련 서비스업이면 잠재소비자의 여가 컬럼 저장
  elif upjong == '숙박업' or upjong=='예술, 스포츠 및 여가관련 서비스업':     
    db_df['잠재소비자']=df_customer['여가']
    db_df['잠재소비자']=db_df['잠재소비자'].fillna(db_df['잠재소비자'].mean())

  # 업종이 음식점이면 잠재소비자의 식료품 컬럼 저장
  elif upjong == '음식점업':           
    db_df['잠재소비자']=df_customer['식료품']
    db_df['잠재소비자']=db_df['잠재소비자'].fillna(db_df['잠재소비자'].mean())
  
  elif upjong == '교육 서비스업':
    db_df['잠재소비자']=df_customer['교육']
    db_df['잠재소비자']=db_df['잠재소비자'].fillna(db_df['잠재소비자'].mean())
  
  elif upjong == '보건의료업':
    db_df['잠재소비자']=df_customer['의료']
    db_df['잠재소비자']=db_df['잠재소비자'].fillna(db_df['잠재소비자'].mean())

  # 이외에 잠재소비자 컬럼으로 분류할 수 없는 업종들은 총 소비자 기준으로 구합니다
  else:
    db_df['잠재소비자']=df_customer['총 금액'] 
    db_df['잠재소비자']=db_df['잠재소비자'].fillna(db_df['잠재소비자'].mean())   

  db_df['임대료']=merge_fee_drop      # 임대료 데이터 저장
  db_df['임대료']=db_df['임대료'].fillna(np.mean(db_df['임대료']))
  
  db_df['폐업률']=final_closed_drop   # 폐업률 데이터 저장
  db_df['폐업률']=db_df['폐업률'].fillna(np.mean(db_df['폐업률']))

  db_df['매출']=final_sales_drop      # 매출 데이터 저장
  db_df['매출']=db_df['매출'].fillna(np.mean(db_df['매출']))

  df_sum=0
  for i in range(4):      # 점수화: 가중치는 1순위는 40%, 2순위는 30%, 3순위는 20%, 4순위는 10%
    if weight[i]-1==1 or weight[i]-1==2:        # 폐업률, 임대료는 수가 작을수록 높은 rank를 갖도록 함 
      df_sum+=db_df.iloc[:, weight[i]-1].rank(ascending=True)*(40-(10*i))     # 각 컬럼에 rank를 매기고 가중치를 곱해준 후 그 총합을 구함
    else:                   # 잠재소비자, 매출은 수가 클수록 높은 rank를 갖도록 함 (ascending=False)
      df_sum+=db_df.iloc[:, weight[i]-1].rank(ascending=False)*(40-(10*i))

  df_sum=df_sum/100

  samescored=df_sum.duplicated(keep=False)          # 동점값 찾기
  samescoresindex=df_sum[samescored].index          # 어느 동이 동점을 갖는지 알아냄
  
  filterdong=filter.set_index('행정동명')
  # 점수화함수 기준으로 동점인 값도 약간의 차등을 두기 위해 블루오션에서 사용했던 지수 비교
  ssstandard=filterdong.loc[samescoresindex]['지수'].rank()     # 동점을 갖는 동들의 블루오션 지수에 rank를 매김
  ssstandard=ssstandard/20              # 블루오션 지수는 동점인 동들 사이에만 순위에 영향을 끼치도록 수를 가공
  sstandard=ssstandard.reindex(df_sum.index)  
  filled_standard=sstandard.fillna(0)       # NaN 값 빼면 결과도 Nan으로 나와서 전부 0으로 채워줌

  df_sum=df_sum-filled_standard           # 각 점수에서 블루오션 점수를 뺌-동점인 행 간 차등이 생김

  return df_sum.sort_values().head(3), db_df    # 순위가 가장 높은 상위 3개 값 출력



#프로그램 실행 코드
final_category_kor, category_kor, category_code =business_filter()
filtered=bluefilter(category_code, df_bus, df_dongpeo, final_category_kor)
w=score_weight()
result_dongs=score(filtered, category[1], w)     #result_dongs[0]은 상위 3개 동, result_dongs[1]은 전체 동 데이터입니다!
i=1
for dong in result_dongs[0].index:
  print(i,'순위 동은', dong+'입니다.')      # 점수화함수 결과 출력
  i=i+1


# 시각화에 쓸 데이터프레임 생성
first_dong=pd.DataFrame(result_dongs[1].loc[result_dongs[0].index[0]])
second_dong=pd.DataFrame(result_dongs[1].loc[result_dongs[0].index[1]])
third_dong=pd.DataFrame(result_dongs[1].loc[result_dongs[0].index[2]])

final_dong = pd.concat([first_dong, second_dong, third_dong],axis=1).transpose()


#추가정보 제공(정보 시각화)
while True:
  ans = input('\n❤️ 추천 3개동에 대한 위치와 추가 정보 제공을 원한다면 1을, 아니면 2를 입력해주세요: ')
  if ans=='1':
    print("\n\n❤️ 추천 3개 동의 총생활인구와 동종업계 수를 비교합니다.\n")

    dong_compare = pd.DataFrame(columns=filtered.columns)
    threedong = result_dongs[0]
    df_threedong=pd.DataFrame(threedong)
    # threedong에 있는 각 행정동명을 순회하면서 처리
    for dong in threedong.index:
        for i in range(len(filtered)):
            if filtered.iloc[i, 3] == dong:
                matching_rows = filtered.iloc[[i]]
                dong_compare = dong_compare.append(matching_rows)
    dong_compare = dong_compare.reset_index(drop=True)

    bar_width = 0.5
    total_peo=np.array(dong_compare['총생활인구'])
    same_bus=np.array(dong_compare['동종업계 수'])
    dong_name=dong_compare.iloc[:, 3]

    plt.rc('font', family='NanumBarunGothic')
    plt.title('생활인구&동종업계 비교 그래프')

    # 생활인구 그래프 바, 값을 그대로 그래프화하면 동종업계 수가 거의 보이지 않기 때문에, 적절한 값으로 생활인구를 나누어주었다
    b1 = plt.bar(dong_compare.index, total_peo/10000, color='#9BCA3E', label='생활인구/10^4') 
    # 동종업계 수 그래프 바
    b2 = plt.bar(dong_compare.index, same_bus, color='#66B5D7', label='동종업계 수') 

    plt.xlabel('행정동명', size = 13)
    plt.xticks(dong_compare.index, labels=dong_name)
    plt.legend()
    plt.show()


    print("\n\n❤️ 추천 3개 동의 잠재소비자 수, 폐업률, 임대료, 매출을 비교합니다.\n")

    # y축 값 저장
    ys1 = final_dong['잠재소비자'].to_list()
    ys2 = final_dong['폐업률'].to_list()
    ys3 = final_dong['임대료'].to_list()
    ys4 = final_dong['매출'].to_list()

    # 그래프 배열 생성
    fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(8, 8))

    # 각 subplot에 그래프 그리기
    axs[0, 0].bar(final_dong.index, ys1, width=0.6, color='b')
    axs[0, 0].set_title('상위 3개 동의 잠재소비자 수 비교')
    axs[0, 1].bar(final_dong.index, ys2, width=0.6, color='b')
    axs[0, 1].set_title('상위 3개 동의 폐업률 비교')
    axs[1, 0].bar(final_dong.index, ys3, width=0.6, color='b')
    axs[1, 0].set_title('상위 3개 동의 임대료 비교')
    axs[1, 1].bar(final_dong.index, ys4, width=0.6, color='b')
    axs[1, 1].set_title('상위 3개 동의 매출 비교')

    # 그래프 크기, x축, y축 이름 설정
    plt.subplots_adjust(wspace=0.3, hspace=0.5)
    for ax in axs.flat:
        ax.set_xlabel('상위 3개 동')
        ax.set_ylabel('값')
        ax.tick_params(axis='x', labelrotation=45) # x축 라벨 회전
    plt.show()
    break
  elif ans=='2':
    print('끝!')
    break
  else:
    print('\n잘못 입력하셨습니다. 다시 선택해주세요')
